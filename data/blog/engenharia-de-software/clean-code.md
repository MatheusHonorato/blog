---
title: 'Clean code: O mÃ­nimo que vocÃª precisa saber'
date: '2021-10-6'
tags: ['clean code', 'cÃ³digo limpo', 'engenharia de software']
draft: false
summary: 'Neste artigo vocÃª aprenderÃ¡ como melhorar a qualidade do seu cÃ³digo utilizando clean code.'
image: '/static/images/clean-code-porta.jpg'
---

VocÃª sabe que o principal gargalo no desenvolvimento de software Ã© justamente a manutenÃ§Ã£o? Ou seja, um cÃ³digo mal escrito desde a sua primeira versÃ£o pode funcionar, mas vai gerar muitos prejuÃ­zos.

O que Ã© caro em um projeto de software nÃ£o sÃ£o os momentos iniciais e as primeiras features, mas sim a manutenÃ§Ã£o e evoluÃ§Ã£o, momento em que trabalhamos com muito cÃ³digo jÃ¡ existente.

Gastamos em mÃ©dia dez vezes mais tempo lendo cÃ³digo do que programando. Sendo assim Ã© importante que se enscreva pensando em quem vai ler, afinal estamos nos comunicando com outros desenvolvedores por meio do cÃ³digo. Se a comunicaÃ§Ã£o Ã© ruim desperdiÃ§amos tempo e muitas vezes atÃ© inviabilizamos o projeto. Uma boa forma de percebermos isso Ã© analisando o grÃ¡fico a seguir.

![Produtividade x Tempo](/static/images/clean-code-produtividadeXtempo.png)

## O que Ã©

Agora que vocÃª sabe da importÃ¢ncia de escrever um bom cÃ³digo para que seja mais fÃ¡cil evoluir e dar manutenÃ§Ã£o, parte mais cara do processo, estÃ¡ na hora de saber o que Ã© clean code e como isso pode te ajudar a codificar melhor.

De acordo com Robert Cecil Martin, conhecido na comunidade como Uncle Bob e autor do livro Clean Code: A Handbook of Agile Software Craftsmanship, cÃ³digo limpo Ã© um cÃ³digo claro e fÃ¡cil de ser mantido, diz o que faz e pode ser lido como uma histÃ³ria, possibilitando uma maior legibilidade e manutenabilidade.

![CLEAN CODE](/static/images/clean-code-uncle-bob.png)

## Principais pontos

A seguir vocÃª irÃ¡ ter acesso a um resumo dos principais pontos sobre clean code. Este artigo Ã© uma introduÃ§Ã£o ao cÃ³digo limpo, sendo assim iremos focar nos pontos mais bÃ¡sicos, presentes nos primeiros capÃ­tulos do livro.

#### Regra do escoteiro

Sempre deixe o cÃ³digo mais limpo do que estava antes. Se deixamos sempre o cÃ³digo que trabalhamos melhor do que encontramos, o cÃ³digo nÃ£o se degrada. NÃ£o precisa necessariamente serem sempre grandes mudanÃ§as, a refatoraÃ§Ã£o do nome de uma variÃ¡vel ou funÃ§Ã£o jÃ¡ causa grande impacto.

#### Nomes sÃ£o muito importantes

O nome precisa passar de cara a sua ideia central. NÃ£o se preocupe se o nome ficar extenso o importante Ã© que ele diga claramente o que estÃ¡ representando.

##### VariÃ¡veis

* ##### Utilize nomes de variÃ¡veis que revelem sua intenÃ§Ã£o

Os nomes das variÃ¡veis devem representar o que armazenam, por exemplo, faz mais sentido colocar os dados de um usuÃ¡rio em uma variÃ¡vel chamada user do que em uma chamada x.

Exemplo:

```javascript
// ruim ðŸ‘Ž
let x = {}; // objeto contendo dados do usuÃ¡rio
// bom ðŸ˜ƒ
let user = {}; // objeto contendo dados do usuÃ¡rio
```

* ##### Utilize nomes pronunciÃ¡veis e passÃ­veis de busca

AlÃ©m de revelar a intenÃ§Ã£o, precisamos ser capazes de pronunciar, melhor ainda se podermos pesquisar por eles no cÃ³digo com facilidade. A principal ideia Ã© que estamos escrevendo cÃ³digos legÃ­veis para humanos. Utilizar siglas, diminutivos ou abreviaÃ§Ãµes, sÃ³ vÃ£o te fazer pensar mais, vocÃª perderÃ¡ tempo deduzindo a intenÃ§Ã£o da variÃ¡vel.

Exemplo:

```javascript
// ruim ðŸ‘Ž
let cy = new Date().getFullYear();
// bom ðŸ˜ƒ
let currentYear = new Date().getFullYear();
```

* ##### NÃ£o adicione palavras desnecessÃ¡rias

Ã‰ bem comum adicionar alguma palavra para dar contexto a variÃ¡vel. Um exemplo seria um objeto que retorne as permissÃµes de um usuÃ¡rio. No exemplo a seguir, se removermos a palavra roles, o cÃ³digo serÃ¡ perfeitamente compreendido.

Exemplo:

```javascript
// ruim ðŸ‘Ž
let roles = {
  rolesUser: [{}],
  rolesGuest: [{}],
  roleManager: [{}],
}
// bom ðŸ˜ƒ
let roles = {
  user: [{}],
  guest: [{}],
  manager: [{}],
}
```

* ##### NÃ£o use o tipo da variÃ¡vel no nome

Uma abordagem antiga era adicionarmos um prefixo no nome das variÃ¡veis. Hoje, isto jÃ¡ nÃ£o Ã© mais uma boa prÃ¡tica. Atribuir um prefixo sÃ³ aumentarÃ¡ a complexidade do seu cÃ³digo, algo que nÃ£o contribui no projeto.

Exemplo:

```javascript
// ruim ðŸ‘Ž
let sName = '';
let aProducts = [];
let dPrice = 12.1;
// bom ðŸ˜ƒ
let name = '';
let products = [];
let price = 12.1;
```

* ##### NÃ£o utilize nÃºmeros ou strings mÃ¡gicas

Quando vocÃª estiver escrevendo cÃ³digo, nunca atribua uma string ou nÃºmero direto no cÃ³digo fonte (hardcode) a uma variÃ¡vel. Declare uma constante e atribua o valor a esta constante.

Exemplo:

```javascript
// ruim ðŸ‘Ž
setTimeout (checkAuthentication, 1000); 
user.role = "guest";
// bom ðŸ˜ƒ
const TIME_AWAIT = 1000; 
const GUEST_ROLE = "guest";
setTimeout (checkAuthentication, TIME_AWAIT); 
user.rolE = GUEST_ROLE;
```

* ##### Defina um vocabulÃ¡rio para o mesmo tipo de dado

Se vocÃª precisa recuperar informaÃ§Ãµes de um produto, todos do time devem se referir a este dado de forma igual. Na prÃ¡tica, Ã© bem comum ver declaraÃ§Ãµes que retornam o mesmo tipo de dados com nomes diferentes. Por exemplo, getProductData, getProductInfo ou getProductDetails retornam os mesmos dados de um produto. Simplifique e use apenas getProduct().

Neste tipo de situaÃ§Ã£o Ã© importante que se adote uma convenÃ§Ã£o que faÃ§a sentido para seu time e contexto de negÃ³cio.

Exemplo:

```javascript
// ruim ðŸ‘Ž
getProductData();
getProductInfo();
getProductDetails();
// todos retornam os dados do produto.
// bom ðŸ˜ƒ
getProduct();
```

##### MÃ©todos ou FunÃ§Ãµes


* ##### FunÃ§Ãµes devem expressar uma aÃ§Ã£o

MÃ©todos e funÃ§Ãµes devem ter nome de verbos, para assim, expressar quais sÃ£o suas finalidades.

Uma boa prÃ¡tica Ã© usar um verbo no tempo verbal infinitivo, aÃ§Ãµes como BuscaCliente, DadosProduto ou BuscaPedido, seria nomeado como getCustomer, getProduct e getInvoice.

Exemplo:

```javascript
// ruim ðŸ‘Ž
buscaCliente();
dadosProduto();
buscaPedido();
// bom ðŸ˜ƒ
getCustomer();
getProduct();
getInvoice();
```

* ##### Para classes e objetos utilize substantivos

Uma boa prÃ¡tica para nomearmos nossas classes seria utilizando substantivos.

Exemplo: 

```javascript
// ruim ðŸ‘Ž
let X = class {
  constructor(heigth, width) {
    this.heigth = heigth;
    this.width = width;
  }
};

// bom ðŸ˜ƒ
let Rectangle = class {
  constructor(heigth, width) {
    this.heigth = heigth;
    this.width = width;
  }
};
```

#### FunÃ§Ãµes

* ##### FunÃ§Ãµes devem executar apenas uma tarefa

"As funÃ§Ãµes devem fazer uma coisa. Devem fazÃª-la bem. Devem fazer apenas ela."

O problema seria o que Ã© 'fazer uma coisa'? se suas tarefas estÃ£o todas um nÃ­vel de abstraÃ§Ã£o abaixo da sua funÃ§Ã£o entÃ£o ela faz somente uma coisa.

Exemplo: 

```javascript
// ruim ðŸ‘Ž
function parseBetterJSAlternative(code) {
  const REGEXES = [
    // ...
  ];

  const statements = code.split(' ');
  const tokens = [];
  REGEXES.forEach((REGEX) => {
    statements.forEach((statement) => {
      // ...
    });
  });

  const ast = [];
  tokens.forEach((token) => {
    // lex...
  });

  ast.forEach((node) => {
    // parse...
  });
}

// bom ðŸ˜ƒ
function tokenize(code) {
  const REGEXES = [
    // ...
  ];

  const statements = code.split(' ');
  const tokens = [];
  REGEXES.forEach((REGEX) => {
    statements.forEach((statement) => {
      tokens.push( /* ... */ );
    });
  });

  return tokens;
}

function lexer(tokens) {
  const ast = [];
  tokens.forEach((token) => {
    ast.push( /* ... */ );
  });

  return ast;
}

function parseBetterJSAlternative(code) {
  const tokens = tokenize(code);
  const ast = lexer(tokens);
  ast.forEach((node) => {
    // parse...
  });
}
```

* ##### FunÃ§Ãµes devem ser pequenas

  De acordo com o autor funÃ§Ãµes longas e com muitos nÃ­veis de abstraÃ§Ã£o dificultam a compreenÃ§Ã£o do cÃ³digo. Sendo assim Uncle Bob reforÃ§a por meio dos dois itens abaixo a importÃ¢ncia de funÃ§Ãµes pequenas para facilitar a manutenÃ§Ã£o e compreenÃ§Ã£o. 

  * As funÃ§Ãµes precisam ser pequenas;
  * Elas tÃªm de ser ainda menores.

```javascript
// ruim ðŸ‘Ž
function emailClients(clients) {
  clients.forEach((client) => {
    const clientRecord = database.lookup(client);
    if (clientRecord.isActive()) {
      email(client);
    }
  });
}

// bom ðŸ˜ƒ
function emailActiveClients(clients) {
  clients
    .filter(isActiveClient)
    .forEach(email);
}

function isActiveClient(client) {
  const clientRecord = database.lookup(client);
  return clientRecord.isActive();
}
```

#### Comente apenas o necessÃ¡rio

ComentÃ¡rios mentem! CÃ³digos sÃ£o constantemente modificados enquanto os comentÃ¡rios sÃ£o esquecidos.

Uma boa observaÃ§Ã£o Ã© nÃ£o utilizar o comentÃ¡rio para explicar a lÃ³gica implementada. Se o cÃ³digo precisa de um comentÃ¡rio para explicar o que faz provavelmente nÃ£o estÃ¡ bem escrito.

Deixe os comentÃ¡rios apenas para ocasiÃµes realmente necessÃ¡rias como, uma soluÃ§Ã£o que foi implementada de determinada forma por limitaÃ§Ã£o tÃ©cnica ou algo do tipo.

```javascript
// ruim ðŸ‘Ž

// This method writes to file
writeFile();

// bom ðŸ˜ƒ

// Don't run unless you have time
writeFile();
```

#### DRY (Donâ€™t Repeat Yourself)

NÃ£o pode existir duas partes do programa que desempenhem a mesma funÃ§Ã£o.

Evite cÃ³digo duplicado. CÃ³digo duplicado quer dizer que existe mais de um lugar onde vocÃª deverÃ¡ alterar algo se precisar mudar alguma lÃ³gica.

Exemplo: 

```javascript
// ruim ðŸ‘Ž
function showDeveloperList(developers) {
  developers.forEach((developer) => {
    const expectedSalary = developer.calculateExpectedSalary();
    const experience = developer.getExperience();
    const githubLink = developer.getGithubLink();
    const data = {
      expectedSalary,
      experience,
      githubLink
    };

    render(data);
  });
}

function showManagerList(managers) {
  managers.forEach((manager) => {
    const expectedSalary = manager.calculateExpectedSalary();
    const experience = manager.getExperience();
    const portfolio = manager.getMBAProjects();
    const data = {
      expectedSalary,
      experience,
      portfolio
    };

    render(data);
  });
}

// bom ðŸ˜ƒ
function showEmployeeList(employees) {
  employees.forEach((employee) => {
    const expectedSalary = employee.calculateExpectedSalary();
    const experience = employee.getExperience();

    const data = {
      expectedSalary,
      experience
    };

    switch(employee.type){
      case 'manager':
        data.portfolio = employee.getMBAProjects();
        break;
      case 'developer':
        data.githubLink = employee.getGithubLink();
        break;
    }

    render(data);
  });
}
```

#### KISS

Normalmente tendemos a complicar as coisas que poderiam ser muito mais simples.

EntÃ£o, Keep It Stupid Simple (Mantenha isto estupidamente simples - KISS)!

# E aÃ­.. curtiu? comenta aÃ­

Procurei neste artigo pontuar os principais itens da obra para quem estÃ¡ comeÃ§ando, mas Ã© muito importante que leia este e outros livros do Uncle Bob para se aprofundar em como codificar melhor. Se vocÃª gostou do conteÃºdo compartilhe com o mÃ¡ximo de pessoas que puder. Se tiver condiÃ§Ãµes de adquirir o livro vocÃª pode comprar por este link.
